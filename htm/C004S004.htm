<html><head><title>[CRISP] 4.4 Creating formations</title></head>
<body bgcolor="ffffff">
<a name = "I20"></a>
<h1>4.4 Creating formations</h1><p>
<p>
<a name = "I21"></a>

A nonempty group class is a  formation if it is closed with respect to factor
groups and residually closed. A saturated formation is, of course, a
formation which is saturated. Note that by the
Gasch&uuml;tz-Lubeseder-Schmid theorem (see e.&nbsp;g. <a href="biblio.htm#DH92"><cite>DH92</cite></a>, IV,
4.6), every saturated formation is a local formation. Moreover, every
saturated formation is a Schunck class. Therefore a saturated formation
admits the operations <code>Boundary</code>, <code>Basis</code>, and <code>Projector</code>.
<p>
<a name = "I22"></a>
<li><code>OrdinaryFormation(</code><var>rec</var><code>) O</code>
<p>
creates a formation from the record <var>rec</var>. Note that it is the user's responsibility to ensure that <var>rec</var> really
defines a formation. <var>rec</var> may have components <code>\in</code>,
<code>res</code>, <code>char</code>, and <code>name</code>, whose values are stored in the attributes
<code>MemberFunction</code>, <code>ResidualFunction</code>, <code>Characteristic</code>, and
<code>Name</code>, respectively, of the new formation. See <a href="C004S005.htm">ResidualFunction</a> below for the meaning of
<code>ResidualFunction</code>.
<p>
The following example shows how to construct the formations of all groups of 
derived length at most <var>3</var> and of all groups of exponent dividing <var>6</var>.
<p>
<pre>
gap&gt; der3 := OrdinaryFormation (rec (
&gt;    res := G -&gt; DerivedSubgroup (DerivedSubgroup (DerivedSubgroup (G)))
&gt; ));
OrdinaryFormation (res:=function( G ) ... end)
gap&gt; SymmetricGroup (4) in der3;
true
gap&gt; GL (2,3) in der3;
false
gap&gt; exp6 := OrdinaryFormation (rec (
&gt;    \in := G -&gt; 6 mod Exponent (G) = 0,
&gt;    char := [2,3]));
OrdinaryFormation (in:=function( G ) ... end)
</pre>
<p>
<a name = "I23"></a>
<li><code>SaturatedFormation(</code><var>rec</var><code>) O</code>
<p>
creates a saturated formation from the record <var>rec</var>. Note that it is the user's responsibility to ensure that <var>rec</var> really
defines a saturated formation. <var>rec</var> may have any
components admissible for formations (see <a href="C004S004.htm">OrdinaryFormation</a>) or Schunck
classes (see <a href="C004S001.htm">SchunckClass</a>), that is, <code>\in</code>, <code>res</code>, <code>char</code>, <code>proj</code>,
<code>bound</code>, <code>locdef</code>, and <code>name</code>, 
 whose values are stored in the attributes <code>MemberFunction</code>,
<code>ResidualFunction</code>, <code>Characteristic</code>,  <code>ProjectorFunction</code>,
<code>BoundaryFunction</code>, <code>LocalDefinitionFunction</code>, and
<code>Name</code>, respectively, if available.  See <a href="C004S005.htm">ResidualFunction</a> and <a href="C004S005.htm">LocalDefinitionFunction</a> below
for the meaning of <code>ResidualFunction</code> and <code>LocalDefinitionFunction</code>.
<p>
There are also functions <code>FittingFormation</code> and <code>SaturatedFittingFormation</code>
to create Fitting
formations and saturated Fitting formations; see
 <a href="C005S002.htm">FittingFormation</a> and <a href="C005S002.htm">SaturatedFittingFormation</a> below for details. 
<p>
The following example shows how to construct the saturated formations of
all finite nilpotent groups and of
all nilpotent-by-abelian groups whose order is not divisible by a
prime congruent 3 mod 4, and whose <var>2</var>-chief factors are central. In the first case, we choose
<var>f(p) = (1)</var> for all primes <var>p</var>, so that the <var>f(p)</var>-residual of <var>G</var> is generated by a
generating set of <var>G</var> (see <a href="C004S005.htm">LocalDefinitionFunction</a> below). In the second example, we let 
<var>f(2) = 1</var>, if <var>p equiv 3
pmod 4</var>, we define <var>f(p) = cal A</var>, the class of all finite abelian groups, and set <var>f(p) =
emptyset</var> otherwise.
<p>
<pre>
gap&gt; nilp := SaturatedFormation (rec (
&gt;      locdef := function (G, p)
&gt;          return SmallGeneratingSet (G);
&gt;      end));
SaturatedFormation (locdef:=function( G, p ) ... end)
gap&gt; form := SaturatedFormation (rec (
&gt;    locdef := function (G, p)
&gt;        if p = 2 then
&gt;           return SmallGeneratingSet (G);
&gt;        elif p mod 4 = 3 then
&gt;           return SmallGeneratingSet (DerivedSubgroup (G));
&gt;        else
&gt;           return fail;
&gt;        fi;
&gt;     end));
SaturatedFormation (locdef:=function( G, p ) ... end)
gap&gt; Projector (GL(2,3), form);
Group([ [ [ Z(3), 0*Z(3) ], [ 0*Z(3), Z(3)^0 ] ], 
  [ [ Z(3)^0, Z(3) ], [ 0*Z(3), Z(3)^0 ] ], 
  [ [ Z(3), 0*Z(3) ], [ 0*Z(3), Z(3) ] ] ])
</pre>
<p>
<a name = "I24"></a>
<li><code>FormationProduct(</code><var>form1</var><code>, </code><var>form2</var><code>) O</code>
<p>
The formation product <var>prod</var> of two formations <var>form1</var> and <var>form2</var> 
consists  of the groups <var>G</var> such that the <var>form2</var>-residual of <var>G</var> belongs to
<var>form1</var>. The product <var>prod</var> is again a formation. If <var>form1</var>
and <var>form2</var> are saturated formations, the result is a saturated
formation. The same is true if the characteristic of <var>form2</var> is contained in
that of <var>form1</var>. This is automatically recognised if the characteristic of
<var>form1</var> is <code>AllPrimes</code> (see <a href="C006S003.htm">AllPrimes</a>). In all other cases, you
will have to set the attribute <code>IsSaturated</code> manually, if applicable. Note
that in general it is not possible for CRISP to determine if two classes
are contained in each other.
<p>
<pre>
gap&gt; nilp := SaturatedFormation (rec (\in := IsNilpotent, name := "nilp"));
nilp
gap&gt; FormationProduct (nilp, der3); # no characteristic known
FormationProduct (nilp, OrdinaryFormation (res:=function( G ) ... end))
gap&gt; HasIsSaturated (last);HasCharacteristic (nilp);
false
false
gap&gt; SetCharacteristic (nilp, AllPrimes);
gap&gt; FormationProduct (nilp, der3); # try with characteristic
FormationProduct (nilp, OrdinaryFormation (res:=function( G ) ... end))
gap&gt; IsSaturated (last);
true
</pre>
<p>
<a name = "I25"></a>
<li><code>FittingFormationProduct(</code><var>fitform1</var><code>, </code><var>fitform2</var><code>) O</code>
<p>
If <var>fitform1</var> and <var>fitform2</var>  are Fitting formations, the formation product
equals the Fitting product (see <a href="C005S001.htm">FittingProduct</a>) of <var>fitform1</var> and
<var>fitform2</var>, which, in turn, equals the class product of <var>fitform1</var> and
<var>fitform2</var>. The latter consists of all groups <var>G</var> having a  normal subgroup
<var>N</var> in <var>fitform1</var> such that <var><var>G</var>/<var>N</var></var> belongs to <var>fitform2</var>.
<p>
Note that if <var>fitform1</var> and <var>fitform2</var> are Fitting formations, then 
<code>FormationProduct(</code><var>fitform1</var><code>, </code><var>fitform2</var><code>)</code>, <code>FittingProduct(</code><var>fitform1</var><code>,
</code><var>fitform2</var><code>)</code> and <code>FittingFormationProduct(</code><var>fitform1</var><code>, </code><var>fitform2</var><code>)</code> all
return the same mathematical object (but distinct GAP objects), which is,
again, a Fitting formation.
<p>
<pre>
gap&gt; nilp := FittingFormation (rec (\in := IsNilpotent, name := "nilp"));;
gap&gt; FormationProduct (nilp, nilp);
FittingFormationProduct (nilp, nilp)
gap&gt; FittingProduct (nilp, nilp);
FittingFormationProduct (nilp, nilp)
gap&gt; FittingFormationProduct (nilp, nilp);
FittingFormationProduct (nilp, nilp)
</pre>
<p>
[<a href ="C004S003.htm">Previous</a>] [<a href = "C004S000.htm">Up</a>] [<a href ="C004S005.htm">Next</a>] [<a href = "theindex.htm">Index</a>]
<P>
<address>GAP 4 manual<br>November 2000
</address></body></html>